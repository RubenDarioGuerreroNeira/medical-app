// import { Inject, Injectable, Logger } from "@nestjs/common";
// import { AppointmentService } from "./appointment.service";
// import TelegramBot from "node-telegram-bot-api";
// import * as moment from "moment-timezone";

// @Injectable()
// export class AppointmentCommands {
//   private readonly logger = new Logger(AppointmentCommands.name);
//   private userStates: Map<number, any> = new Map();

//   constructor(
//     private readonly appointmentService: AppointmentService,

//     private readonly bot: TelegramBot,
//     @Inject("USER_STATES_MAP") userStatesMap: Map<number, any>
//   ) {
//     this.userStates = userStatesMap;
//   }

//   setupCommands() {
//     // Otros manejadores...
//     this.bot.removeAllListeners("callback_query");
//     this.bot.on("callback_query", async (callbackQuery) => {
//       if (!callbackQuery.message) return;
//       const chatId = callbackQuery.message.chat.id;

//       // if (callbackQuery.data === "nuevacita") {
//       //   await this.iniciarCreacionCita(chatId);
//       // } else if (callbackQuery.data === "ver_citas") {
//       //   await this.mostrarCitasConIds(chatId, "show");
//       // } else if (callbackQuery.data === "select_edit_appointment") {
//       //   await this.bot.sendMessage(
//       //     chatId,
//       //     "‚úèÔ∏è Por favor, ingresa el ID de la cita que deseas editar:"
//       //   );
//       //   this.setupEditAppointmentHandler(chatId);
//       // } else if (callbackQuery.data === "select_delete_appointment") {
//       //   await this.bot.sendMessage(
//       //     chatId,
//       //     "üóëÔ∏è Por favor, ingresa el ID de la cita que deseas eliminar:"
//       //   );
//       //   this.setupDeleteAppointmentHandler(chatId);
//       // } else if (callbackQuery.data.startsWith("edit_appointment_")) {
//       //   const appointmentId = parseInt(callbackQuery.data.split("_")[2]);
//       //   await this.iniciarEdicionCita(chatId, appointmentId);
//       // } else if (callbackQuery.data.startsWith("delete_appointment_")) {
//       //   const appointmentId = parseInt(callbackQuery.data.split("_")[2]);
//       //   await this.confirmarEliminarCita(chatId, appointmentId);
//       // } else if (callbackQuery.data === "confirm_delete_appointment") {
//       //   const state = this.userStates.get(chatId);
//       //   if (state && state.appointmentToDelete) {
//       //     await this.eliminarCita(chatId, state.appointmentToDelete);
//       //   }
//       // } else if (callbackQuery.data === "cancel_delete_appointment") {
//       //   await this.bot.sendMessage(chatId, "‚ùå Eliminaci√≥n cancelada");
//       //   this.userStates.delete(chatId);
//       // }
//     });
//   }

//   // A√±adir este m√©todo a la clase AppointmentCommands
//   public async mostrarMenuCitas(chatId: number) {
//     await this.bot.sendMessage(
//       chatId,
//       "üìÖ *Gesti√≥n de Citas M√©dicas*\n\nPuedes programar y administrar tus citas m√©dicas.",
//       {
//         parse_mode: "Markdown",
//         reply_markup: {
//           inline_keyboard: [
//             [
//               {
//                 text: "‚ûï Crear nueva cita",
//                 callback_data: "nuevacita",
//               },
//             ],
//             [
//               {
//                 text: "üìã Ver √≥ Editar mis citas",
//                 callback_data: "ver_citas",
//               },
//             ],
//             [
//               {
//                 text: "üîô Volver al men√∫ principal",
//                 callback_data: "menu_principal",
//               },
//             ],
//           ],
//         },
//       }
//     );
//   }

//   async iniciarCreacionCita(chatId: number) {
//     this.userStates.set(chatId, {
//       // step: "doctor_name",
//       currentOperation: "create_appointment",
//       step: "awaiting doctor_name",
//       appointmentData: {},
//     });

//     // await this.bot.sendMessage(
//     const sentMessage = await this.bot.sendMessage(
//       chatId,
//       "üë®‚Äç‚öïÔ∏è Por favor, ingresa el nombre del doctor:"
//     );

//     // Configurar manejador de mensajes para el proceso de creaci√≥n
//     // this.setupAppointmentMessageHandler(chatId);
//     // Telegram Service Will now Route The reply to handleUserInput
//   }

//   private setupAppointmentMessageHandler(chatId: number) {
//     // elimina cualquier manejador previo para evitar redundancia
//     // this.bot.removeAllListeners("message");
//     const messageHandler = async (msg: TelegramBot.Message) => {
//       if (msg.chat.id !== chatId || !msg.text) return;

//       const state = this.userStates.get(chatId);
//       if (!state) return;
//       try {
//         // Definir timeRegex aqu√≠ para que est√© disponible en todos los casos
//         const timeRegex = /^([01]\d|2[0-3]):([0-5]\d)$/; // Validar formato HH:MM

//         switch (state.step) {
//           case "doctor_name":
//             if (msg.text.trim().length === 0) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå El nombre del doctor no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
//               );
//               return;
//             }
//             state.appointmentData.doctorName = msg.text;
//             state.step = "specialty";
//             await this.bot.sendMessage(
//               chatId,
//               "üî¨ ¬øCu√°l es la especialidad m√©dica?"
//             );
//             break;

//           case "specialty":
//             if (msg.text.trim().length === 0) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå La especialidad no puede estar vac√≠a. Por favor, ingr√©sala nuevamente."
//               );
//               return;
//             }
//             state.appointmentData.specialty = msg.text;
//             state.step = "date";
//             await this.bot.sendMessage(
//               chatId,
//               "üìÖ ¬øEn qu√© fecha es la cita? (Formato: DD-MM-AAAA, ejemplo: 21-05-2025)"
//             );
//             break;

//           case "date":
//             try {
//               const dateObj = moment(msg.text, "DD-MM-YYYY", true);
//               if (!dateObj.isValid()) {
//                 throw new Error("Formato de fecha inv√°lido");
//               }
//               state.appointmentData.appointmentDate = msg.text; // Guardar en formato original
//               state.step = "time";
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚è∞ ¬øA qu√© hora es la cita? (Ejemplo: 02:30 PM o 14:30)"
//               );
//             } catch (error) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå Formato de fecha inv√°lido. Por favor, usa el formato DD-MM-YYYY (ejemplo: 21-05-2025)"
//               );
//             }
//             break;

//           case "time":
//             // Modificar la expresi√≥n regular para aceptar formato AM/PM
//             // Formato 12h: 1:30 PM, 03:45 am, etc.
//             // Formato 24h: 13:30, 03:45, etc.
//             const timeRegexAMPM =
//               /^(0?[1-9]|1[0-2]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
//             const timeRegex24h = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;

//             if (!timeRegexAMPM.test(msg.text) && !timeRegex24h.test(msg.text)) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå Formato de hora inv√°lido. Por favor, usa el formato HH:MM AM/PM (ejemplo: 02:30 PM) o HH:MM (ejemplo: 14:30)"
//               );
//               return;
//             }

//             state.appointmentData.appointmentTime = msg.text;

//             state.step = "medical_center";
//             await this.bot.sendMessage(
//               chatId,
//               "üè• ¬øEn qu√© centro m√©dico es la cita?"
//             );
//             break;

//           case "medical_center":
//             if (msg.text.trim().length === 0) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå El nombre del centro m√©dico no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
//               );
//               return;
//             }
//             state.appointmentData.medicalCenterName = msg.text;
//             state.step = "location";
//             await this.bot.sendMessage(
//               chatId,
//               "üìç ¬øCu√°l es la ubicaci√≥n del centro m√©dico? (Opcional, env√≠a 'N' si no deseas especificar)"
//             );
//             break;

//           case "location":
//             state.appointmentData.medicalCenterLocation =
//               msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
//             state.step = "phone";
//             await this.bot.sendMessage(
//               chatId,
//               "üìû ¬øCu√°l es el n√∫mero de tel√©fono de contacto? (Opcional, env√≠a 'N' si no deseas especificar)"
//             );
//             break;

//           case "phone":
//             state.appointmentData.phoneNumber =
//               msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
//             state.step = "notes";
//             await this.bot.sendMessage(
//               chatId,
//               "üìù ¬øDeseas agregar alguna nota adicional? (Opcional, env√≠a 'N' si no deseas especificar)"
//             );
//             break;

//           case "notes":
//             state.appointmentData.notes =
//               msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
//             await this.finalizarCreacionCita(chatId, state.appointmentData);
//             break;

//           // Edici√≥n de citas
//           case "edit_doctor_name":
//             if (msg.text.trim().length === 0) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå El nombre del doctor no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
//               );
//               return;
//             }
//             state.appointmentData.doctorName = msg.text;
//             state.step = "edit_specialty";
//             await this.bot.sendMessage(
//               chatId,
//               "üî¨ ¬øCu√°l es la nueva especialidad m√©dica?"
//             );
//             break;

//           case "edit_specialty":
//             state.appointmentData.specialty = msg.text;

//             state.step = "edit_date";
//             await this.bot.sendMessage(
//               chatId,
//               "üìÖ ¬øCu√°l es la nueva fecha de la cita? (Formato: DD-MM-AAAA)"
//             );
//             break;

//           case "edit_date":
//             try {
//               const dateObj = moment(msg.text, "DD-MM-YYYY", true);
//               if (!dateObj.isValid()) {
//                 throw new Error("Formato de fecha inv√°lido");
//               }
//               state.appointmentData.appointmentDate = msg.text;
//               // guarda en formato original

//               state.step = "edit_time";
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚è∞ ¬øCu√°l es la nueva hora de la cita? (Formato: HH:MM, ejemplo 02:30 pm √≥ 14:30)"
//               );
//             } catch (error) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå Formato de fecha inv√°lido. Por favor, usa el formato DD-MM-AAAA, (ejemplo: 29-09-2025)"
//               );
//             }
//             break;

//           case "edit_time":
//             const editTimeRegexAMPM =
//               /^(0?[1-9]|1[0-2]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
//             const editTimeRegex24h = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;

//             if (
//               !editTimeRegexAMPM.test(msg.text) &&
//               !editTimeRegex24h.test(msg.text)
//             ) {
//               await this.bot.sendMessage(
//                 chatId,
//                 "‚ùå Formato de hora inv√°lido. Por favor, usa el formato HH:MM AM/PM (ejemplo: 02:30 PM) o HH:MM (ejemplo:02:30 PM √≥ 14:30)"
//               );
//               return;
//             }
//             state.appointmentData.appointmentTime = msg.text;
//             state.step = "edit_medical_center";
//             await this.bot.sendMessage(
//               chatId,
//               "üè• ¬øCu√°l es el nuevo centro m√©dico?"
//             );
//             break;

//           case "edit_medical_center":
//             state.appointmentData.medicalCenterName = msg.text;
//             await this.finalizarEdicionCita(chatId, state.appointmentData);
//             break;

//           default:
//             await this.bot.sendMessage(
//               chatId,
//               "‚ùå Ocurri√≥ un error inesperado. Por favor, intenta nuevamente."
//             );
//             break;
//         }
//       } catch (error) {
//         this.logger.error(`Error en el flujo de mensajes: ${error.message}`);
//         await this.bot.sendMessage(
//           chatId,
//           "‚ùå Ocurri√≥ un error inesperado. Por favor, intenta nuevamente."
//         );
//       }
//     };

//     // Registrar el manejador de mensajes
//     this.bot.on("message", messageHandler);
//   }

//   private async finalizarCreacionCita(chatId: number, appointmentData: any) {
//     try {
//       const appointment = await this.appointmentService.createAppointment(
//         chatId,
//         appointmentData
//       );

//       const formattedDate = moment(appointment.appointmentDate).format(
//         "DD/MM/YYYY"
//       );

//       await this.bot.sendMessage(
//         chatId,
//         `‚úÖ Cita m√©dica creada exitosamente:\n\n` +
//           `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
//           `üî¨ Especialidad: ${appointment.specialty}\n` +
//           `üìÖ Fecha: ${formattedDate}\n` +
//           `‚è∞ Hora: ${appointment.appointmentTime}\n` +
//           `üè• Centro M√©dico: ${appointment.medicalCenterName}\n` +
//           (appointment.medicalCenterLocation
//             ? `üìç Ubicaci√≥n: ${appointment.medicalCenterLocation}\n`
//             : "") +
//           (appointment.phoneNumber
//             ? `üìû Tel√©fono: ${appointment.phoneNumber}\n`
//             : "") +
//           (appointment.notes ? `üìù Notas: ${appointment.notes}\n` : ""),
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "Ver mis citas",
//                   callback_data: "ver_citas",
//                 },
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );

//       // Limpiar el estado del usuario
//       this.userStates.delete(chatId);
//     } catch (error) {
//       this.logger.error(`Error al crear cita: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al crear la cita. Por favor, intenta nuevamente.",
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "üìã Volver al men√∫ de citas",
//                   callback_data: "ver_citas",
//                 },
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );
//     }
//   }

//   private async finalizarEdicionCita(chatId: number, appointmentData: any) {
//     try {
//       const appointment = await this.appointmentService.createAppointment(
//         chatId,
//         appointmentData
//       );

//       const formattedDate = moment(appointment.appointmentDate).format(
//         "DD/MM/YYYY"
//       );

//       await this.bot.sendMessage(
//         chatId,
//         `‚úÖ Cita m√©dica creada exitosamente:\n\n` +
//           `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
//           `üî¨ Especialidad: ${appointment.specialty}\n` +
//           `üìÖ Fecha: ${formattedDate}\n` +
//           `‚è∞ Hora: ${appointment.appointmentTime}\n` +
//           `üè• Centro M√©dico: ${appointment.medicalCenterName}\n` +
//           (appointment.medicalCenterLocation
//             ? `üìç Ubicaci√≥n: ${appointment.medicalCenterLocation}\n`
//             : "") +
//           (appointment.phoneNumber
//             ? `üìû Tel√©fono: ${appointment.phoneNumber}\n`
//             : "") +
//           (appointment.notes ? `üìù Notas: ${appointment.notes}\n` : ""),
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "Ver mis citas",
//                   callback_data: "ver_citas",
//                 },
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );

//       // Limpiar el estado del usuario
//       this.userStates.delete(chatId);
//     } catch (error) {
//       this.logger.error(`Error al crear cita: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al actualizar la cita. Por favor, intenta nuevamente.",
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "üìã Volver al men√∫ de citas",
//                   callback_data: "ver_citas",
//                 },
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );
//     }
//   }

//   private async iniciarEdicionCita(chatId: number, appointmentId: number) {
//     this.bot.removeAllListeners("message");
//     try {
//       const appointment = await this.appointmentService.getAppointmentById(
//         appointmentId
//       );

//       if (!appointment) {
//         await this.bot.sendMessage(chatId, "‚ùå No se encontr√≥ la cita m√©dica.");
//         return;
//       }

//       this.userStates.set(chatId, {
//         step: "edit_doctor_name",
//         appointmentData: { ...appointment },
//       });

//       await this.bot.sendMessage(
//         chatId,
//         `‚úèÔ∏è Editando cita m√©dica:\n\n` +
//           `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
//           `üî¨ Especialidad: ${appointment.specialty}\n` +
//           `üìÖ Fecha: ${appointment.appointmentDate}\n` +
//           `‚è∞ Hora: ${appointment.appointmentTime}\n` +
//           `üè• Centro M√©dico: ${appointment.medicalCenterName}\n\n` +
//           `Por favor, ingresa el nuevo nombre del doctor (o escribe el mismo nombre para no cambiarlo):`
//       );

//       this.setupAppointmentMessageHandler(chatId);
//     } catch (error) {
//       this.logger.error(`Error al iniciar edici√≥n: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al iniciar la edici√≥n de la cita.",
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );
//     }
//   }

//   private async confirmarEliminarCita(chatId: number, appointmentId: number) {
//     this.bot.removeAllListeners("message");
//     try {
//       this.userStates.set(chatId, {
//         appointmentToDelete: appointmentId,
//       });

//       await this.bot.sendMessage(
//         chatId,
//         "¬øEst√°s seguro de que deseas eliminar esta cita m√©dica?",
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "‚úÖ S√≠, eliminar",
//                   callback_data: "confirm_delete_appointment",
//                 },
//                 {
//                   text: "‚ùå No, cancelar",
//                   callback_data: "cancel_delete_appointment",
//                 },
//               ],
//             ],
//           },
//         }
//       );
//     } catch (error) {
//       this.logger.error(`Error al confirmar eliminaci√≥n: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al procesar la solicitud"
//       );
//     }
//   }

//   private async mostrarCitasConIds(
//     chatId: number,
//     action: "show" | "edit" | "delete"
//   ) {
//     try {
//       const appointments = await this.appointmentService.getUserAppointments(
//         chatId
//       );

//       if (appointments.length === 0) {
//         await this.bot.sendMessage(
//           chatId,
//           "No tienes citas m√©dicas programadas."
//         );
//         return;
//       }

//       // Mostrar lista de citas con sus IDs
//       let message = "üìã *Tus citas m√©dicas:*\n\n";
//       for (const appointment of appointments) {
//         const formattedDate = moment(appointment.appointmentDate).format(
//           "DD/MM/YYYY"
//         );

//         message += `üÜî *ID: ${appointment.id}*\n`;
//         message += `üè• ${appointment.medicalCenterName}\n`;
//         message += `üë®‚Äç‚öïÔ∏è Dr. ${appointment.doctorName} - ${appointment.specialty}\n`;
//         message += `üìÖ ${formattedDate} ‚è∞ ${appointment.appointmentTime}\n\n`;
//       }

//       await this.bot.sendMessage(chatId, message, {
//         parse_mode: "Markdown",
//       });

//       // Preguntar qu√© acci√≥n desea realizar
//       await this.bot.sendMessage(chatId, "¬øQu√© acci√≥n deseas realizar?", {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               {
//                 text: "‚úèÔ∏è Editar una cita",
//                 callback_data: "select_edit_appointment",
//               },
//               {
//                 text: "üóëÔ∏è Eliminar una cita",
//                 callback_data: "select_delete_appointment",
//               },
//             ],
//             [
//               { text: "‚ûï Nueva cita", callback_data: "nuevacita" },
//               {
//                 text: "üîô Volver al men√∫ principal",
//                 callback_data: "menu_principal",
//               },
//             ],
//           ],
//         },
//       });
//     } catch (error) {
//       this.logger.error(`Error al mostrar citas: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al obtener tus citas. Por favor, intenta nuevamente."
//       );
//     }
//   }

//   private setupDeleteAppointmentHandler(chatId: number) {
//     // Eliminar cualquier manejador previo para evitar duplicados
//     this.bot.removeAllListeners("message");

//     const messageHandler = async (msg: TelegramBot.Message) => {
//       if (msg.chat.id !== chatId || !msg.text) return;

//       const appointmentId = parseInt(msg.text.trim());
//       if (isNaN(appointmentId)) {
//         await this.bot.sendMessage(
//           chatId,
//           "‚ùå ID inv√°lido. Por favor, ingresa un n√∫mero v√°lido."
//         );
//         return;
//       }

//       try {
//         const appointment = await this.appointmentService.getAppointmentById(
//           appointmentId
//         );

//         if (!appointment) {
//           await this.bot.sendMessage(
//             chatId,
//             "‚ùå No se encontr√≥ una cita con ese ID. Por favor, intenta nuevamente."
//           );
//           return;
//         }

//         // Configurar el estado del usuario para la eliminaci√≥n
//         this.userStates.set(chatId, {
//           appointmentToDelete: appointmentId,
//         });

//         await this.bot.sendMessage(
//           chatId,
//           `üóëÔ∏è ¬øEst√°s seguro de que deseas eliminar esta cita m√©dica?\n\n` +
//             `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
//             `üî¨ Especialidad: ${appointment.specialty}\n` +
//             `üìÖ Fecha: ${appointment.appointmentDate}\n` +
//             `‚è∞ Hora: ${appointment.appointmentTime}\n` +
//             `üè• Centro M√©dico: ${appointment.medicalCenterName}`,
//           {
//             reply_markup: {
//               inline_keyboard: [
//                 [
//                   {
//                     text: "‚úÖ S√≠, eliminar",
//                     callback_data: "confirm_delete_appointment",
//                   },
//                   {
//                     text: "‚ùå No, cancelar",
//                     callback_data: "cancel_delete_appointment",
//                   },
//                 ],
//               ],
//             },
//           }
//         );
//       } catch (error) {
//         this.logger.error(`Error al obtener cita: ${error.message}`);
//         await this.bot.sendMessage(
//           chatId,
//           "‚ùå Ocurri√≥ un error al buscar la cita. Por favor, intenta nuevamente."
//         );
//       }
//     };

//     // Registrar el manejador de mensajes
//     this.bot.on("message", messageHandler);
//   }

//   private setupEditAppointmentHandler(chatId: number) {
//     // Eliminar cualquier manejador previo para evitar duplicados
//     this.bot.removeAllListeners("message");

//     const messageHandler = async (msg: TelegramBot.Message) => {
//       if (msg.chat.id !== chatId || !msg.text) return;

//       // Eliminar el manejador despu√©s de recibir el mensaje
//       this.bot.removeListener("message", messageHandler);

//       const appointmentId = parseInt(msg.text.trim());
//       if (isNaN(appointmentId)) {
//         await this.bot.sendMessage(
//           chatId,
//           "‚ùå ID inv√°lido. Por favor, ingresa un n√∫mero v√°lido."
//         );
//         return;
//       }

//       try {
//         const appointment = await this.appointmentService.getAppointmentById(
//           appointmentId
//         );

//         if (!appointment) {
//           await this.bot.sendMessage(
//             chatId,
//             "‚ùå No se encontr√≥ una cita con ese ID. Por favor, intenta nuevamente."
//           );
//           return;
//         }

//         // Configurar el estado del usuario para la edici√≥n
//         this.userStates.set(chatId, {
//           step: "edit_doctor_name",
//           appointmentData: { ...appointment },
//         });

//         await this.bot.sendMessage(
//           chatId,
//           `‚úèÔ∏è Editando cita m√©dica:\n\n` +
//             `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
//             `üî¨ Especialidad: ${appointment.specialty}\n` +
//             `üìÖ Fecha: ${appointment.appointmentDate}\n` +
//             `‚è∞ Hora: ${appointment.appointmentTime}\n` +
//             `üè• Centro M√©dico: ${appointment.medicalCenterName}\n\n` +
//             `Por favor, ingresa el nuevo nombre del doctor (o escribe el mismo nombre para no cambiarlo):`
//         );

//         // Configurar el manejador para el flujo de edici√≥n
//         this.setupAppointmentMessageHandler(chatId);
//       } catch (error) {
//         this.logger.error(`Error al obtener cita: ${error.message}`);
//         await this.bot.sendMessage(
//           chatId,
//           "‚ùå Ocurri√≥ un error al buscar la cita. Por favor, intenta nuevamente."
//         );
//       }
//     };

//     // Registrar el manejador de mensajes
//     this.bot.on("message", messageHandler);
//   }

//   private async eliminarCita(chatId: number, appointmentId: number) {
//     this.bot.removeAllListeners("message");
//     try {
//       await this.appointmentService.deleteAppointment(appointmentId);
//       await this.bot.sendMessage(chatId, "‚úÖ Cita eliminada exitosamente", {
//         reply_markup: {
//           inline_keyboard: [
//             [
//               {
//                 text: "üìã Volver al men√∫ de citas",
//                 callback_data: "ver_citas",
//               },
//               {
//                 text: "üîô Volver al men√∫ principal",
//                 callback_data: "menu_principal",
//               },
//             ],
//           ],
//         },
//       });
//       this.userStates.delete(chatId);
//     } catch (error) {
//       this.logger.error(`Error al eliminar cita: ${error.message}`);
//       await this.bot.sendMessage(
//         chatId,
//         "‚ùå Ocurri√≥ un error al eliminar la cita",
//         {
//           reply_markup: {
//             inline_keyboard: [
//               [
//                 {
//                   text: "üìã Volver al men√∫ de citas",
//                   callback_data: "ver_citas",
//                 },
//                 {
//                   text: "üîô Volver al men√∫ principal",
//                   callback_data: "menu_principal",
//                 },
//               ],
//             ],
//           },
//         }
//       );
//     }
//   }
// }

import { Inject, Injectable, Logger } from "@nestjs/common";
import { AppointmentService } from "./appointment.service";
import TelegramBot from "node-telegram-bot-api";
import * as moment from "moment-timezone";

@Injectable()
export class AppointmentCommands {
  private readonly logger = new Logger(AppointmentCommands.name);
  private userStates: Map<number, any>; // Ya no se inicializa aqu√≠, se inyecta

  constructor(
    private readonly appointmentService: AppointmentService,
    private readonly bot: TelegramBot,
    @Inject("USER_STATES_MAP") userStatesMap: Map<number, any>
  ) {
    this.userStates = userStatesMap;
  }

  // setupCommands() ya no es necesario aqu√≠ para los listeners globales,
  // TelegramService se encargar√° de ello.
  // Los listeners espec√≠ficos como onReplyToMessage o once('callback_query') para mensajes muy concretos
  // podr√≠an permanecer si son autogestionados y no interfieren.
  // Por ahora, lo eliminamos para seguir el patr√≥n de centralizaci√≥n.

  public async mostrarMenuCitas(chatId: number) {
    await this.bot.sendMessage(
      chatId,
      "üìÖ *Gesti√≥n de Citas M√©dicas*\n\nPuedes programar y administrar tus citas m√©dicas.",
      {
        parse_mode: "Markdown",
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "‚ûï Crear nueva cita",
                callback_data: "nuevacita",
              },
            ],
            [
              {
                text: "üìã Ver √≥ Editar mis citas",
                callback_data: "ver_citas",
              },
            ],
            [
              {
                text: "üîô Volver al men√∫ principal",
                callback_data: "menu_principal",
              },
            ],
          ],
        },
      }
    );
  }

  async iniciarCreacionCita(chatId: number) {
    this.userStates.set(chatId, {
      currentOperation: "create_appointment",
      step: "awaiting_doctor_name", // Cambiado para reflejar que esperamos este dato
      appointmentData: {},
    });

    await this.bot.sendMessage(
      chatId,
      "üë®‚Äç‚öïÔ∏è Por favor, ingresa el nombre del doctor:"
    );
    // TelegramService enrutar√° la respuesta del usuario a handleUserInput
  }

  public async handleAppointmentCallback(
    chatId: number,
    callbackQuery: TelegramBot.CallbackQuery
  ): Promise<void> {
    const data = callbackQuery.data;
    if (!data) return;

    // TelegramService ya deber√≠a haber respondido al callbackQuery.id

    if (data === "nuevacita") {
      await this.iniciarCreacionCita(chatId);
    } else if (data === "ver_citas") {
      await this.mostrarCitasConIds(chatId, "show"); // "show" es un placeholder, ajustar seg√∫n necesidad
    } else if (data === "select_edit_appointment") {
      this.userStates.set(chatId, {
        currentOperation: "edit_appointment",
        step: "awaiting_id_for_edit",
      });
      await this.bot.sendMessage(
        chatId,
        "‚úèÔ∏è Por favor, ingresa el ID de la cita que deseas editar:"
      );
    } else if (data === "select_delete_appointment") {
      this.userStates.set(chatId, {
        currentOperation: "delete_appointment",
        step: "awaiting_id_for_delete",
      });
      await this.bot.sendMessage(
        chatId,
        "üóëÔ∏è Por favor, ingresa el ID de la cita que deseas eliminar:"
      );
    } else if (data.startsWith("edit_appointment_")) {
      const appointmentId = parseInt(data.split("_")[2]);
      await this.iniciarEdicionCita(chatId, appointmentId);
    } else if (data.startsWith("delete_appointment_")) {
      const appointmentId = parseInt(data.split("_")[2]);
      await this.confirmarEliminarCita(chatId, appointmentId);
    } else if (data === "confirm_delete_appointment") {
      const state = this.userStates.get(chatId);
      if (state && state.appointmentToDeleteId) {
        await this.eliminarCita(chatId, state.appointmentToDeleteId);
      }
      this.userStates.delete(chatId); // Limpiar estado despu√©s de la operaci√≥n
    } else if (data === "cancel_delete_appointment") {
      await this.bot.sendMessage(chatId, "‚ùå Eliminaci√≥n cancelada");
      this.userStates.delete(chatId); // Limpiar estado
    }
  }

  public async handleUserInput(msg: TelegramBot.Message): Promise<void> {
    const chatId = msg.chat.id;
    if (!msg.text) return;

    const state = this.userStates.get(chatId);
    if (
      !state ||
      (state.currentOperation !== "create_appointment" &&
        state.currentOperation !== "edit_appointment" &&
        state.currentOperation !== "delete_appointment")
    ) {
      // No est√° en un flujo de citas o el estado es incorrecto
      return;
    }

    try {
      // Manejar entrada de ID para editar/eliminar primero
      if (state.step === "awaiting_id_for_edit") {
        const appointmentId = parseInt(msg.text.trim());
        if (isNaN(appointmentId)) {
          await this.bot.sendMessage(
            chatId,
            "‚ùå ID inv√°lido. Por favor, ingresa un n√∫mero v√°lido."
          );
          return;
        }
        await this.iniciarEdicionCita(chatId, appointmentId);
        return;
      } else if (state.step === "awaiting_id_for_delete") {
        const appointmentId = parseInt(msg.text.trim());
        if (isNaN(appointmentId)) {
          await this.bot.sendMessage(
            chatId,
            "‚ùå ID inv√°lido. Por favor, ingresa un n√∫mero v√°lido."
          );
          return;
        }
        // En lugar de llamar a setupDeleteAppointmentHandler, procesamos directamente
        await this.processIdForDelete(chatId, appointmentId);
        return;
      }

      // L√≥gica de creaci√≥n/edici√≥n de citas basada en state.step
      switch (state.step) {
        // --- Flujo de Creaci√≥n ---
        case "awaiting_doctor_name":
          if (msg.text.trim().length === 0) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå El nombre del doctor no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
            );
            return;
          }
          state.appointmentData.doctorName = msg.text;
          state.step = "awaiting_specialty";
          this.userStates.set(chatId, state); // Guardar estado actualizado
          await this.bot.sendMessage(
            chatId,
            "üî¨ ¬øCu√°l es la especialidad m√©dica?"
          );
          break;

        case "awaiting_specialty":
          if (msg.text.trim().length === 0) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå La especialidad no puede estar vac√≠a. Por favor, ingr√©sala nuevamente."
            );
            return;
          }
          state.appointmentData.specialty = msg.text;
          state.step = "awaiting_date";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üìÖ ¬øEn qu√© fecha es la cita? (Formato: DD-MM-AAAA, ejemplo: 21-05-2025)"
          );
          break;

        case "awaiting_date":
          try {
            const dateObj = moment(msg.text, "DD-MM-YYYY", true);
            if (!dateObj.isValid()) {
              throw new Error("Formato de fecha inv√°lido");
            }
            state.appointmentData.appointmentDate = msg.text; // Guardar en formato original
            state.step = "awaiting_time";
            this.userStates.set(chatId, state);
            await this.bot.sendMessage(
              chatId,
              "‚è∞ ¬øA qu√© hora es la cita? (Ejemplo: 02:30 PM o 14:30)"
            );
          } catch (error) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå Formato de fecha inv√°lido. Por favor, usa el formato DD-MM-YYYY (ejemplo: 21-05-2025)"
            );
          }
          break;

        case "awaiting_time":
          const timeRegexAMPM = /^(0?[1-9]|1[0-2]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
          const timeRegex24h = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
          if (!timeRegexAMPM.test(msg.text) && !timeRegex24h.test(msg.text)) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå Formato de hora inv√°lido. Por favor, usa el formato HH:MM AM/PM (ejemplo: 02:30 PM) o HH:MM (ejemplo: 14:30)"
            );
            return;
          }
          state.appointmentData.appointmentTime = msg.text;
          state.step = "awaiting_medical_center";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üè• ¬øEn qu√© centro m√©dico es la cita?"
          );
          break;

        case "awaiting_medical_center":
          if (msg.text.trim().length === 0) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå El nombre del centro m√©dico no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
            );
            return;
          }
          state.appointmentData.medicalCenterName = msg.text;
          state.step = "awaiting_location";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üìç ¬øCu√°l es la ubicaci√≥n del centro m√©dico? (Opcional, env√≠a 'N' si no deseas especificar)"
          );
          break;

        case "awaiting_location":
          state.appointmentData.medicalCenterLocation =
            msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
          state.step = "awaiting_phone";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üìû ¬øCu√°l es el n√∫mero de tel√©fono de contacto? (Opcional, env√≠a 'N' si no deseas especificar)"
          );
          break;

        case "awaiting_phone":
          state.appointmentData.phoneNumber =
            msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
          state.step = "awaiting_notes";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üìù ¬øDeseas agregar alguna nota adicional? (Opcional, env√≠a 'N' si no deseas especificar)"
          );
          break;

        case "awaiting_notes":
          state.appointmentData.notes =
            msg.text.trim().toUpperCase() === "N" ? "" : msg.text;
          await this.finalizarCreacionCita(chatId, state.appointmentData);
          // El estado se limpia en finalizarCreacionCita
          break;

        // --- Flujo de Edici√≥n ---
        case "awaiting_edit_doctor_name":
          if (msg.text.trim().length === 0) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå El nombre del doctor no puede estar vac√≠o. Por favor, ingr√©salo nuevamente."
            );
            return;
          }
          state.appointmentData.doctorName = msg.text;
          state.step = "awaiting_edit_specialty";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üî¨ ¬øCu√°l es la nueva especialidad m√©dica?"
          );
          break;

        case "awaiting_edit_specialty":
          state.appointmentData.specialty = msg.text;
          state.step = "awaiting_edit_date";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üìÖ ¬øCu√°l es la nueva fecha de la cita? (Formato: DD-MM-AAAA)"
          );
          break;

        case "awaiting_edit_date":
          try {
            const dateObj = moment(msg.text, "DD-MM-YYYY", true);
            if (!dateObj.isValid()) {
              throw new Error("Formato de fecha inv√°lido");
            }
            state.appointmentData.appointmentDate = msg.text;
            state.step = "awaiting_edit_time";
            this.userStates.set(chatId, state);
            await this.bot.sendMessage(
              chatId,
              "‚è∞ ¬øCu√°l es la nueva hora de la cita? (Formato: HH:MM AM/PM o HH:MM)"
            );
          } catch (error) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå Formato de fecha inv√°lido. Por favor, usa el formato DD-MM-AAAA (ejemplo: 29-09-2025)"
            );
          }
          break;

        case "awaiting_edit_time":
          const editTimeRegexAMPM =
            /^(0?[1-9]|1[0-2]):[0-5][0-9]\s*(am|pm|AM|PM)$/;
          const editTimeRegex24h = /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/;
          if (
            !editTimeRegexAMPM.test(msg.text) &&
            !editTimeRegex24h.test(msg.text)
          ) {
            await this.bot.sendMessage(
              chatId,
              "‚ùå Formato de hora inv√°lido. Por favor, usa el formato HH:MM AM/PM o HH:MM."
            );
            return;
          }
          state.appointmentData.appointmentTime = msg.text;
          state.step = "awaiting_edit_medical_center";
          this.userStates.set(chatId, state);
          await this.bot.sendMessage(
            chatId,
            "üè• ¬øCu√°l es el nuevo centro m√©dico?"
          );
          break;

        case "awaiting_edit_medical_center":
          state.appointmentData.medicalCenterName = msg.text;
          // El ID de la cita ya deber√≠a estar en state.appointmentData.id desde iniciarEdicionCita
          await this.finalizarEdicionCita(chatId, state.appointmentData);
          // El estado se limpia en finalizarEdicionCita
          break;

        default:
          this.logger.warn(
            `Estado desconocido en handleUserInput: ${state.step} para el chat ${chatId}`
          );
          // Podr√≠as querer limpiar el estado aqu√≠ o enviar un mensaje de error gen√©rico
          // this.userStates.delete(chatId);
          // await this.bot.sendMessage(chatId, "‚ùå Ocurri√≥ un error en el flujo. Por favor, intenta comenzar de nuevo.");
          break;
      }
    } catch (error) {
      this.logger.error(
        `Error en handleUserInput para el chat ${chatId}, estado ${JSON.stringify(
          state
        )}: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        "‚ùå Ocurri√≥ un error inesperado procesando tu respuesta. Por favor, intenta nuevamente."
      );
      // Considera limpiar el estado aqu√≠ tambi√©n si el error es irrecuperable
      // this.userStates.delete(chatId);
    }
  }

  private async finalizarCreacionCita(chatId: number, appointmentData: any) {
    try {
      const appointment = await this.appointmentService.createAppointment(
        chatId,
        appointmentData
      );

      const formattedDate = moment(appointment.appointmentDate).format(
        "DD/MM/YYYY"
      );

      await this.bot.sendMessage(
        chatId,
        `‚úÖ Cita m√©dica creada exitosamente:\n\n` +
          `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
          `üî¨ Especialidad: ${appointment.specialty}\n` +
          `üìÖ Fecha: ${formattedDate}\n` +
          `‚è∞ Hora: ${appointment.appointmentTime}\n` +
          `üè• Centro M√©dico: ${appointment.medicalCenterName}\n` +
          (appointment.medicalCenterLocation
            ? `üìç Ubicaci√≥n: ${appointment.medicalCenterLocation}\n`
            : "") +
          (appointment.phoneNumber
            ? `üìû Tel√©fono: ${appointment.phoneNumber}\n`
            : "") +
          (appointment.notes ? `üìù Notas: ${appointment.notes}\n` : ""),
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "Ver mis citas",
                  callback_data: "ver_citas",
                },
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      this.logger.error(`Error al crear cita: ${error.message}`, error.stack);
      await this.bot.sendMessage(
        chatId,
        `‚ùå Ocurri√≥ un error al crear la cita: ${error.message}. Por favor, intenta nuevamente.`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üìã Volver al men√∫ de citas",
                  callback_data: "recordatorio_cita_medica", // O el callback del men√∫ de citas
                },
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    } finally {
      this.userStates.delete(chatId); // Limpiar el estado del usuario
    }
  }

  private async finalizarEdicionCita(chatId: number, appointmentData: any) {
    try {
      // Aseg√∫rate de que appointmentData.id contiene el ID de la cita a actualizar
      if (!appointmentData.id) {
        throw new Error("ID de la cita no encontrado para la actualizaci√≥n.");
      }
      const appointment = await this.appointmentService.updateAppointment(
        appointmentData.id,
        appointmentData
      );

      const formattedDate = moment(appointment.appointmentDate).format(
        "DD/MM/YYYY"
      );

      await this.bot.sendMessage(
        chatId,
        `‚úÖ Cita m√©dica actualizada exitosamente:\n\n` +
          `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
          `üî¨ Especialidad: ${appointment.specialty}\n` +
          `üìÖ Fecha: ${formattedDate}\n` +
          `‚è∞ Hora: ${appointment.appointmentTime}\n` +
          `üè• Centro M√©dico: ${appointment.medicalCenterName}\n` +
          (appointment.medicalCenterLocation
            ? `üìç Ubicaci√≥n: ${appointment.medicalCenterLocation}\n`
            : "") +
          (appointment.phoneNumber
            ? `üìû Tel√©fono: ${appointment.phoneNumber}\n`
            : "") +
          (appointment.notes ? `üìù Notas: ${appointment.notes}\n` : ""),
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "Ver mis citas",
                  callback_data: "ver_citas",
                },
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      this.logger.error(
        `Error al actualizar cita: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        `‚ùå Ocurri√≥ un error al actualizar la cita: ${error.message}. Por favor, intenta nuevamente.`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üìã Volver al men√∫ de citas",
                  callback_data: "recordatorio_cita_medica", // O el callback del men√∫ de citas
                },
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    } finally {
      this.userStates.delete(chatId); // Limpiar el estado del usuario
    }
  }

  private async iniciarEdicionCita(chatId: number, appointmentId: number) {
    try {
      const appointment = await this.appointmentService.getAppointmentById(
        appointmentId
      );

      if (!appointment) {
        await this.bot.sendMessage(chatId, "‚ùå No se encontr√≥ la cita m√©dica.");
        return;
      }

      // Formatear la fecha para mostrarla correctamente
      const formattedDate = moment(appointment.appointmentDate).format(
        "DD/MM/YYYY"
      );

      this.userStates.set(chatId, {
        currentOperation: "edit_appointment",
        step: "awaiting_edit_doctor_name",
        appointmentData: { ...appointment }, // Guardamos toda la cita, incluyendo su ID
      });

      await this.bot.sendMessage(
        chatId,
        `‚úèÔ∏è Editando cita m√©dica (ID: ${appointment.id}):\n\n` +
          `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
          `üî¨ Especialidad: ${appointment.specialty}\n` +
          `üìÖ Fecha: ${formattedDate}\n` + // Usar fecha formateada
          `‚è∞ Hora: ${appointment.appointmentTime}\n` +
          `üè• Centro M√©dico: ${appointment.medicalCenterName}\n\n` +
          `Por favor, ingresa el nuevo nombre del doctor (o escribe el mismo nombre para no cambiarlo):`
      );
      // TelegramService enrutar√° la respuesta del usuario a handleUserInput
    } catch (error) {
      this.logger.error(
        `Error al iniciar edici√≥n: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        "‚ùå Ocurri√≥ un error al iniciar la edici√≥n de la cita.",
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    }
  }

  private async confirmarEliminarCita(chatId: number, appointmentId: number) {
    try {
      const appointment = await this.appointmentService.getAppointmentById(
        appointmentId
      );
      if (!appointment) {
        await this.bot.sendMessage(
          chatId,
          "‚ùå No se encontr√≥ la cita m√©dica para eliminar."
        );
        return;
      }

      this.userStates.set(chatId, {
        currentOperation: "delete_appointment_confirmation", // Estado espec√≠fico para la confirmaci√≥n
        appointmentToDeleteId: appointmentId, // Guardar el ID de la cita a eliminar
      });

      const formattedDate = moment(appointment.appointmentDate).format(
        "DD/MM/YYYY"
      );

      await this.bot.sendMessage(
        chatId,
        `üóëÔ∏è ¬øEst√°s seguro de que deseas eliminar esta cita m√©dica (ID: ${appointment.id})?\n\n` +
          `üë®‚Äç‚öïÔ∏è Doctor: ${appointment.doctorName}\n` +
          `üî¨ Especialidad: ${appointment.specialty}\n` +
          `üìÖ Fecha: ${formattedDate}\n` +
          `‚è∞ Hora: ${appointment.appointmentTime}\n` +
          `üè• Centro M√©dico: ${appointment.medicalCenterName}`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "‚úÖ S√≠, eliminar",
                  callback_data: "confirm_delete_appointment",
                },
                {
                  text: "‚ùå No, cancelar",
                  callback_data: "cancel_delete_appointment",
                },
              ],
            ],
          },
        }
      );
    } catch (error) {
      this.logger.error(
        `Error al confirmar eliminaci√≥n: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        "‚ùå Ocurri√≥ un error al procesar la solicitud de eliminaci√≥n."
      );
    }
  }

  private async mostrarCitasConIds(
    chatId: number,
    action: "show" | "edit" | "delete" // 'action' podr√≠a usarse para personalizar el mensaje si es necesario
  ) {
    try {
      const appointments = await this.appointmentService.getUserAppointments(
        chatId
      );

      if (appointments.length === 0) {
        await this.bot.sendMessage(
          chatId,
          "No tienes citas m√©dicas programadas.",
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "‚ûï Nueva cita", callback_data: "nuevacita" }],
                [
                  {
                    text: "üîô Volver al men√∫ principal",
                    callback_data: "menu_principal",
                  },
                ],
              ],
            },
          }
        );
        return;
      }

      let message = "üìã *Tus citas m√©dicas:*\n\n";
      const inline_keyboard_buttons = [];

      for (const appointment of appointments) {
        const formattedDate = moment(appointment.appointmentDate).format(
          "DD/MM/YYYY"
        );
        message += `üÜî *ID: ${appointment.id}*\n`;
        message += `üè• ${appointment.medicalCenterName}\n`;
        message += `üë®‚Äç‚öïÔ∏è Dr. ${appointment.doctorName} - ${appointment.specialty}\n`;
        message += `üìÖ ${formattedDate} ‚è∞ ${appointment.appointmentTime}\n\n`;

        // Podr√≠amos a√±adir botones por cada cita si la lista no es muy larga
        // inline_keyboard_buttons.push([
        //   { text: `‚úèÔ∏è ID ${appointment.id}`, callback_data: `edit_appointment_${appointment.id}` },
        //   { text: `üóëÔ∏è ID ${appointment.id}`, callback_data: `delete_appointment_${appointment.id}` }
        // ]);
      }

      await this.bot.sendMessage(chatId, message, {
        parse_mode: "Markdown",
      });

      // Preguntar qu√© acci√≥n desea realizar de forma general
      await this.bot.sendMessage(chatId, "¬øQu√© acci√≥n deseas realizar?", {
        reply_markup: {
          inline_keyboard: [
            // ...inline_keyboard_buttons, // Descomentar si se quieren botones por cita
            [
              {
                text: "‚úèÔ∏è Editar una cita (ingresa ID)",
                callback_data: "select_edit_appointment",
              },
              {
                text: "üóëÔ∏è Eliminar una cita (ingresa ID)",
                callback_data: "select_delete_appointment",
              },
            ],
            [
              { text: "‚ûï Nueva cita", callback_data: "nuevacita" },
              {
                text: "üîô Volver al men√∫ de citas", // O men√∫ principal
                callback_data: "recordatorio_cita_medica",
              },
            ],
            [
              {
                text: "üè† Volver al men√∫ principal",
                callback_data: "menu_principal",
              },
            ],
          ],
        },
      });
    } catch (error) {
      this.logger.error(
        `Error al mostrar citas: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        "‚ùå Ocurri√≥ un error al obtener tus citas. Por favor, intenta nuevamente."
      );
    }
  }

  private async processIdForDelete(chatId: number, appointmentId: number) {
    try {
      const appointment = await this.appointmentService.getAppointmentById(
        appointmentId
      );

      if (!appointment) {
        await this.bot.sendMessage(
          chatId,
          "‚ùå No se encontr√≥ una cita con ese ID. Por favor, intenta nuevamente."
        );
        // Mantener el estado para que pueda reintentar o cancelar
        this.userStates.set(chatId, {
          currentOperation: "delete_appointment",
          step: "awaiting_id_for_delete", // Permanece en este paso
        });
        return;
      }
      // Si se encuentra la cita, proceder a la confirmaci√≥n
      await this.confirmarEliminarCita(chatId, appointmentId);
    } catch (error) {
      this.logger.error(
        `Error al obtener cita para eliminar: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        "‚ùå Ocurri√≥ un error al buscar la cita. Por favor, intenta nuevamente."
      );
      this.userStates.set(chatId, {
        currentOperation: "delete_appointment",
        step: "awaiting_id_for_delete",
      });
    }
  }

  private async eliminarCita(chatId: number, appointmentId: number) {
    try {
      await this.appointmentService.deleteAppointment(appointmentId);
      await this.bot.sendMessage(chatId, "‚úÖ Cita eliminada exitosamente", {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üìã Volver al men√∫ de citas",
                callback_data: "recordatorio_cita_medica", // O el callback del men√∫ de citas
              },
              {
                text: "üîô Volver al men√∫ principal",
                callback_data: "menu_principal",
              },
            ],
          ],
        },
      });
    } catch (error) {
      this.logger.error(
        `Error al eliminar cita: ${error.message}`,
        error.stack
      );
      await this.bot.sendMessage(
        chatId,
        `‚ùå Ocurri√≥ un error al eliminar la cita: ${error.message}`,
        {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: "üìã Volver al men√∫ de citas",
                  callback_data: "recordatorio_cita_medica", // O el callback del men√∫ de citas
                },
                {
                  text: "üîô Volver al men√∫ principal",
                  callback_data: "menu_principal",
                },
              ],
            ],
          },
        }
      );
    } finally {
      this.userStates.delete(chatId); // Limpiar estado
    }
  }
}
